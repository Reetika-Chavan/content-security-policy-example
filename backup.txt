export default async function handler(request, context) {
  try {
    const response = await fetch(request);

    // Process HTML only
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.includes("text/html")) {
      return response;
    }

    let html = await response.text();

    // Extract nonce from CSP header
    const cspHeader = response.headers.get("Content-Security-Policy") || "";
    const nonceMatch = cspHeader.match(/'nonce-([^']+)'/);
    const nonce = nonceMatch ? nonceMatch[1] : null;

    // If no nonce found, return original response
    if (!nonce) {
      return new Response(html, {
        status: response.status,
        statusText: response.statusText,
        headers: response.headers,
      });
    }

    // Add nonce to scripts
    html = html.replace(/<script(?!.*nonce=)/g, `<script nonce="${nonce}"`);

    // Handle dynamic scripts
    const dynamicScriptHandler = `
      <script nonce="${nonce}">
        // Store nonce globally
        window.__NONCE__ = "${nonce}";
        
        // Override createElement
        const originalCreateElement = document.createElement;
        document.createElement = function(tagName) {
          const element = originalCreateElement.call(this, tagName);
          if (tagName.toLowerCase() === 'script' && window.__NONCE__) {
            element.setAttribute('nonce', window.__NONCE__);
          }
          return element;
        };
        
        // Handle innerHTML scripts
        const originalInnerHTMLSetter = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML').set;
        Object.defineProperty(Element.prototype, 'innerHTML', {
          set: function(value) {
            if (typeof value === 'string' && value.includes('<script') && window.__NONCE__) {
              value = value.replace(/<script(?!.*nonce=)/g, '<script nonce="' + window.__NONCE__ + '"');
            }
            originalInnerHTMLSetter.call(this, value);
          },
          get: Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML').get
        });
      </script>`;

    // Insert handler
    html = html.replace("</head>", dynamicScriptHandler + "</head>");

    // Update CSP
    const originalCSP = response.headers.get("Content-Security-Policy") || "";
    let updatedCSP = originalCSP;

    updatedCSP = updatedCSP.replace(/'nonce-null'/g, "");
    updatedCSP = updatedCSP.replace(/'nonce-[^']*'/g, `'nonce-${nonce}'`);

    // Clean up any double spaces or semicolons
    updatedCSP = updatedCSP.replace(/\s+/g, " ").replace(/;\s*;/g, ";").trim();

    // Return response
    const newHeaders = new Headers(response.headers);
    newHeaders.set("Content-Security-Policy", updatedCSP);

    return new Response(html, {
      status: response.status,
      statusText: response.statusText,
      headers: newHeaders,
    });
  } catch (error) {
    console.error("Edge function error:", error);
    return fetch(request);
  }
}

//middleware
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest) {
  // Generate nonce using Web Crypto API
  const nonce = btoa(Math.random().toString() + Date.now().toString()).replace(
    /[^a-zA-Z0-9]/g,
    ""
  );

  // CSP header 
  const cspHeader = [
    "default-src 'self'",
    `script-src-elem 'unsafe-inline' 'strict-dynamic' https: http: 'unsafe-eval' 'nonce-${nonce}'`,
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: blob:",
    "font-src 'self'",
    "object-src 'none'",
    "base-uri 'self'",
    "form-action 'self'",
    "frame-ancestors 'none'",
    "upgrade-insecure-requests",
  ].join("; ");

  const requestHeaders = new Headers(request.headers);
  requestHeaders.set("x-nonce", nonce);

  // Create the response
  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });

  // Add the CSP header to the response
  response.headers.set("Content-Security-Policy", cspHeader);

  return response;
}

